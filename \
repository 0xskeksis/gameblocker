#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>
#include <dirent.h>
#include <fcntl.h>
#include <signal.h>

static const char *BLACKLIST[] = {
    "/Megabonk",
    "/Rayman",
    "Overcooked",
    "/Subnautica",
    "/Balatro",
    NULL
};

char*
build_newdir(const char *src, const char *to_add){
	char	*result;

	result = malloc(sizeof(char) * (strlen("/proc/") + strlen(src) + strlen(to_add) + 1));
	if (result){
		strcpy(result, "/proc/");
		strcpy(result + strlen("/proc/"), src);
		strcpy(result + strlen(result), to_add);
		// printf("[DEBUG]: Result = %s\n", result);
	}
	return result;
}

bool
find_game_in_cmdline(int fd, const char *game){
	char	buffer[512];

	int	bytes_read = read(fd, buffer, sizeof(buffer));
	if (bytes_read == -1)
		return false;
	printf("[DEBUG]: Buffer = %s\n", buffer);
	if (strstr(buffer, game))
		return true;
	return false;
}

int main(){
	pid_t	child = fork();
	assert(child != -1);
	if (child > 1)
		exit(EXIT_SUCCESS);
	setsid();
	child = fork();
	assert(child != -1);
	if (child > 0)
		exit(EXIT_SUCCESS);
	while (1){
		DIR				*d;
		struct dirent	*dir;

		d = opendir("/proc");
		if (d){
			while ((dir = readdir(d)) != NULL){
				for (int i = 0; BLACKLIST[i] != NULL; i++){
					char	*tmp_path = build_newdir(dir->d_name, "/cmdline");
					if (!tmp_path)
						return (1);
					printf("[DEBUG]: tmp_path = %s\n", tmp_path);
					int fd = open(tmp_path, O_RDONLY);
					if (fd > 0){
						if (find_game_in_cmdline(fd, BLACKLIST[i])){
							// kill(atoi(dir->d_name), SIGTERM);
							printf("FIND\n");
						}
					}else{
						printf("[WARNING]: Failed to create the fd\n");
					}
				}
			}
			closedir(d);
		}
	}
	return (0);
}
